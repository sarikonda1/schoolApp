/**
 * BaseWebAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import { Configuration } from '../base/configuration';
import { BASE_PATH } from '../base/variables';
import { CustomHttpUrlEncodingCodec } from '../base/encoder';
import { BaseUrlConfig, ModuleConfig } from 'app/url.config';
import { StoreService } from '../file-management/store.service';
import * as jsPDF from 'jspdf';
import * as XLSX from 'xlsx';
import { formatDate } from '@angular/common';
import { SchoolService } from '../manage-school/school.service';
import { ReportGenerationService } from './generate-pdf.service';
import { Messages } from 'app/app.constants';
@Injectable()
export class SchoolReportsService {

    protected basePath = BaseUrlConfig.BasePath + ModuleConfig.Base;
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration,
        private reportGenerationService: ReportGenerationService,
        private storeService: StoreService, private schoolService: SchoolService) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
      * Report of Admission Application Students AcademicSession-level  Get PreStudent Applications Reports
      * 
      * @param authorization access token
      * @param classes Gets or Sets of Classes
      * @param status Gets or Sets of Status
      * @param sortBy Gets or Sets of SortBy
      * @param sortOrder Gets or Sets of SortOrder
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
    public getPreStudentApplicationReports(classes?: Array<string>,
        status?: Array<string>, sortBy?: string, sortOrder?: 0 | 1 | -1, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getPreStudentApplicationReports(classes?: Array<string>,
        status?: Array<string>, sortBy?: string, sortOrder?: 0 | 1 | -1, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getPreStudentApplicationReports(classes?: Array<string>,
        status?: Array<string>, sortBy?: string, sortOrder?: 0 | 1 | -1, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getPreStudentApplicationReports(classes?: Array<string>,
        status?: Array<string>, sortBy?: string, sortOrder?: 0 | 1 | -1, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classes) {
            classes.forEach((element) => {
                queryParameters = queryParameters.append('Classes', <any>element);
            });
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('Status', <any>element);
            });
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('SortBy', <any>sortBy);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('SortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/pre-student-application-reports`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Report of Student InActive at acdemic session level
     * 
     * @param authorization access token
     * @param schoolId Gets or Sets SchoolId
     * @param schoolAcademicSessionIds Gets or Sets SchoolAcademicSessionId
     * @param classIds Gets or Sets SchoolAcademicSessionId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inActiveStudentsReports(status?: Array<string>, classIds?: Array<number>, section?: Array<string>,
        observe?: 'body', reportProgress?: boolean): Observable<any>;
    public inActiveStudentsReports(status?: Array<string>, classIds?: Array<number>, section?: Array<string>,
        observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public inActiveStudentsReports(status?: Array<string>, classIds?: Array<number>, section?: Array<string>,
        observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public inActiveStudentsReports(status?: Array<string>, classIds?: Array<number>, section?: Array<string>,
        observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });

        if (classIds) {
            classIds.forEach((element) => {
                queryParameters = queryParameters.append('ClassIds', <any>element);
            });
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('Status', <any>element);
            });
        }
        if (section) {
            section.forEach((element) => {
                queryParameters = queryParameters.append('Section', <any>element);
            });
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/inactive-students-report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Report of School Admitted Students School-level, AcademicSession-level, class-SectionLevel
     * 
     * @param authorization access token
     * @param schoolId Gets or Sets SchoolId
     * @param schoolAcademicSessionIds Gets or Sets SchoolAcademicSessionId
     * @param classSectionIds Gets or Sets SchoolAcademicSessionId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public schoolAdmittedStudents(schoolId?: string,
        schoolAcademicSessionIds?: Array<string>, classSectionIds?: Array<any>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public schoolAdmittedStudents(schoolId?: string,
        schoolAcademicSessionIds?: Array<string>, classSectionIds?: Array<any>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public schoolAdmittedStudents(schoolId?: string,
        schoolAcademicSessionIds?: Array<string>, classSectionIds?: Array<any>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public schoolAdmittedStudents(schoolId?: string,
        schoolAcademicSessionIds?: Array<string>, classSectionIds?: Array<any>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (schoolId !== undefined && schoolId !== null) {
            queryParameters = queryParameters.set('SchoolId', <any>schoolId);
        }
        if (schoolAcademicSessionIds) {
            schoolAcademicSessionIds.forEach((element) => {
                queryParameters = queryParameters.append('SchoolAcademicSessionIds', <any>element);
            });
        }
        if (classSectionIds) {
            classSectionIds.forEach((element) => {
                queryParameters = queryParameters.append('ClassSectionIds', <any>element);
            });
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-strength`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Report of Student Concessions at acdemic level
     * 
     * @param authorization access token
     * @param schoolId Gets or Sets SchoolId
     * @param schoolAcademicSessionIds Gets or Sets SchoolAcademicSessionId
     * @param classIds Gets or Sets SchoolAcademicSessionId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentsApplicationSummary(classIds?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public studentsApplicationSummary(classIds?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public studentsApplicationSummary(classIds?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public studentsApplicationSummary(classIds?: Array<number>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classIds) {
            classIds.forEach((element) => {
                queryParameters = queryParameters.append('ClassIds', <any>element);
            });
        }
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-application-summary`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Report of Student Concessions at acdemic level
     * 
     * @param authorization access token
     * @param studentConcessionGroupId Gets or Sets StudentConcessionGroupIds
     * @param classId Gets or Sets ClassId
     * @param sectionId Gets or Sets SectionId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentsFeeConcessions(classId?: string, studentConcessionGroupId?: string,  sectionId?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public studentsFeeConcessions(classId?: string, studentConcessionGroupId?: string,
         sectionId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public studentsFeeConcessions(classId?: string, studentConcessionGroupId?: string,
         sectionId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public studentsFeeConcessions(classId?: string, studentConcessionGroupId?: string,
         sectionId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (studentConcessionGroupId !== undefined && studentConcessionGroupId !== null) {
            queryParameters = queryParameters.set('StudentConcessionGroupId', <any>studentConcessionGroupId);
        }
        if (classId !== undefined && classId !== null) {
            queryParameters = queryParameters.set('ClassId', <any>classId);
        }
        if (sectionId !== undefined && sectionId !== null) {
            queryParameters = queryParameters.set('SectionId', <any>sectionId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-fee-concessions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    exportToExcel(tableId: any, name?: string): void {
        const timeSpan = new Date().toISOString();
        const prefix = name || 'ExportResult';
        const fileName = `${prefix}`;
        const targetTableElm = document.getElementById(tableId);
        const wb = XLSX.utils.table_to_book(targetTableElm, <XLSX.Table2SheetOpts>{ sheet: prefix });
        XLSX.writeFile(wb, `${fileName}.xlsx`);
    }

    /**
     * 
     * 
     * @param authorization access token
     * @param boardId 
     * @param classId 
     * @param sectionId 
     * @param attendanceDate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentAttendance(boardId?: number, classId?: number, sectionId?: number, attendanceDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<any>;
    // tslint:disable-next-line: max-line-length
    public studentAttendance(boardId?: number, classId?: number, sectionId?: number, attendanceDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    // tslint:disable-next-line: max-line-length
    public studentAttendance(boardId?: number, classId?: number, sectionId?: number, attendanceDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    // tslint:disable-next-line: max-line-length
    public studentAttendance(boardId?: number, classId?: number, sectionId?: number, attendanceDate?: Date, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (boardId !== undefined && boardId !== null) {
            queryParameters = queryParameters.set('BoardId', <any>boardId);
        }
        if (classId !== undefined && classId !== null) {
            queryParameters = queryParameters.set('ClassId', <any>classId);
        }
        if (sectionId !== undefined && sectionId !== null) {
            queryParameters = queryParameters.set('SectionId', <any>sectionId);
        }
        if (attendanceDate !== undefined && attendanceDate !== null) {
            queryParameters = queryParameters.set('AttendanceDate', <any>attendanceDate.toISOString());
        }

        let headers = this.defaultHeaders;


        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-attendance-report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Report of Student Payment Corrections
    * 
    * @param authorization access token
    * @param paymentCorrectionDateBegin Gets or sets of PaymentCorrectionDateBegin
    * @param paymentCorrectionDateEnd Gets or sets of PaymentCorrectionDateEnd
    * @param students Gets or sets of Students
    * @param statuses Gets or sets of Statuses
    * @param paymentModes Gets or sets of PaymentModes
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public studentPaymentCorrections(paymentCorrectionDateBegin?: Date, paymentCorrectionDateEnd?: Date, students?: Array<string>,
        statuses?: Array<string>, paymentModes?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public studentPaymentCorrections(paymentCorrectionDateBegin?: Date, paymentCorrectionDateEnd?: Date, students?: Array<string>,
        statuses?: Array<string>, paymentModes?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public studentPaymentCorrections(paymentCorrectionDateBegin?: Date, paymentCorrectionDateEnd?: Date, students?: Array<string>,
        statuses?: Array<string>, paymentModes?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public studentPaymentCorrections(paymentCorrectionDateBegin?: Date, paymentCorrectionDateEnd?: Date, students?: Array<string>,
        statuses?: Array<string>, paymentModes?: Array<string>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (paymentCorrectionDateBegin !== undefined && paymentCorrectionDateBegin !== null) {
            queryParameters = queryParameters.set('PaymentCorrectionDateBegin', <any>paymentCorrectionDateBegin);
        }
        if (paymentCorrectionDateEnd !== undefined && paymentCorrectionDateEnd !== null) {
            queryParameters = queryParameters.set('PaymentCorrectionDateEnd', <any>paymentCorrectionDateEnd);
        }
        if (students) {
            students.forEach((element) => {
                queryParameters = queryParameters.append('Students', <any>element);
            });
        }
        if (statuses) {
            statuses.forEach((element) => {
                queryParameters = queryParameters.append('Statuses', <any>element);
            });
        }
        if (paymentModes) {
            paymentModes.forEach((element) => {
                queryParameters = queryParameters.append('PaymentModes', <any>element);
            });
        }
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-payment-corrections`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Staff Attendance Summary Attendance Report
     * 
     * @param authorization access token
     * @param fromDate Gets or sets of FromDate
     * @param toDate Gets or sets of ToDate
     * @param month Gets or Sets Month
     * @param department Gets or Sets Department
     * @param staffName Gets or Sets Name
     * @param staffCode Gets or Sets Code
     * @param sortOrder Gets or Sets SortOrder
     * @param sortBy Gets or Sets SortBy
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public staffAttendanceSummaryReport(fromDate?: Date, toDate?: Date, month?: Array<number>, department?: string,
        staffName?: string, staffCode?: string, sortOrder?: 0 | 1 | -1, sortBy?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public staffAttendanceSummaryReport(fromDate?: Date, toDate?: Date, month?: Array<number>, department?: string,
        staffName?: string, staffCode?: string, sortOrder?: 0 | 1 | -1, sortBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public staffAttendanceSummaryReport(fromDate?: Date, toDate?: Date, month?: Array<number>, department?: string,
        staffName?: string, staffCode?: string, sortOrder?: 0 | 1 | -1, sortBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public staffAttendanceSummaryReport(fromDate?: Date, toDate?: Date, month?: Array<number>, department?: string,
        staffName?: string, staffCode?: string, sortOrder?: 0 | 1 | -1, sortBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (fromDate !== undefined && fromDate !== null) {
            queryParameters = queryParameters.set('FromDate', <any>fromDate);
        }
        if (toDate !== undefined && toDate !== null) {
            queryParameters = queryParameters.set('ToDate', <any>toDate);
        }
        if (month) {
            month.forEach((element) => {
                queryParameters = queryParameters.append('Month', <any>element);
            });
        }
        if (department !== undefined && department !== null) {
            queryParameters = queryParameters.set('Department', <any>department);
        }
        if (staffName !== undefined && staffName !== null) {
            queryParameters = queryParameters.set('StaffName', <any>staffName);
        }
        if (staffCode !== undefined && staffCode !== null) {
            queryParameters = queryParameters.set('StaffCode', <any>staffCode);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('SortOrder', <any>sortOrder);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('SortBy', <any>sortBy);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/staff-attendance-summary-report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * List of Student details whose Applications which are approved in the given Academic Session and optional Class
    * 
    * @param authorization access token
    * @param id 
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public admittedStudents(id?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public admittedStudents(id?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public admittedStudents(id?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public admittedStudents(id?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('Id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/admitted-students`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
      * Report of Failed Payments Report
      * 
      * @param authorization access token
      * @param failedPaymentsDateBegin Gets or sets of PaymentCorrectionDateBegin
      * @param failedPaymentsDateEnd Gets or sets of PaymentCorrectionDateEnd
      * @param studentId Gets or sets of PaymentCorrectionDateEnd
      * @param statusId Gets or Sets
      * @param paymentMode Gets or Sets
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
    public failedPaymentsReport(failedPaymentsDateBegin?: Date | string,
        failedPaymentsDateEnd?: Date | string, studentId?: string, statusId?: number, paymentMode?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public failedPaymentsReport(failedPaymentsDateBegin?: Date | string,
        failedPaymentsDateEnd?: Date | string, studentId?: string,
        statusId?: number, paymentMode?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public failedPaymentsReport(failedPaymentsDateBegin?: Date | string,
        failedPaymentsDateEnd?: Date | string, studentId?: string,
        statusId?: number, paymentMode?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public failedPaymentsReport(failedPaymentsDateBegin?: Date | string,
        failedPaymentsDateEnd?: Date | string, studentId?: string,
        statusId?: number, paymentMode?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (failedPaymentsDateBegin !== undefined && failedPaymentsDateBegin !== null) {
            queryParameters = queryParameters.set('FailedPaymentsDateBegin', <any>failedPaymentsDateBegin);
        }
        if (failedPaymentsDateEnd !== undefined && failedPaymentsDateEnd !== null) {
            queryParameters = queryParameters.set('FailedPaymentsDateEnd', <any>failedPaymentsDateEnd);
        }
        if (studentId !== undefined && studentId !== null) {
            queryParameters = queryParameters.set('StudentId', <any>studentId);
        }
        if (statusId !== undefined && statusId !== null) {
            queryParameters = queryParameters.set('StatusId', <any>statusId);
        }
        if (paymentMode !== undefined && paymentMode !== null) {
            queryParameters = queryParameters.set('PaymentMode', <any>paymentMode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/failed-payments-report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
   * PaymentsDues of students with respect to Academic Session
   * 
   * @param authorization access token
   * @param classIds 
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
    public paymentsDue(classIds?: Array<any>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public paymentsDue(classIds?: Array<any>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public paymentsDue(classIds?: Array<any>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public paymentsDue(classIds?: Array<any>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classIds) {
            classIds.forEach((element) => {
                queryParameters = queryParameters.append('classIds', <any>element);
            });
        }

        let headers = this.defaultHeaders;


        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-payment-dues`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * ClassAttendanceSummary &#x3D;&amp;gt;
    * Attendance for a class-Section is considered only when ClassAttendance is 
    * marked as complete.  By considering a day in attendance only if the Class 
    * Attendance is marked as complete, yeilding output for every stdent in the class of an academic session with respect to month and year
    * 
    * @param authorization access token
    * @param classId Gets or Sets ClassId
    * @param sectionId Gets or Sets SectionId
    * @param schoolBoadId Gets or Sets SchoolBoadId
    * @param fromDate Gets or Sets FromDate
    * @param toDate Gets or Sets ToDate
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public classAttendanceSummary(classId?: number, sectionId?: number,
        schoolBoadId?: number, minimumPercentageRequired?: number, fromDate?: Date, toDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public classAttendanceSummary(classId?: number, sectionId?: number,
        schoolBoadId?: number, minimumPercentageRequired?: number, fromDate?: Date, toDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public classAttendanceSummary(classId?: number, sectionId?: number,
        schoolBoadId?: number, minimumPercentageRequired?: number, fromDate?: Date, toDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public classAttendanceSummary(classId?: number, sectionId?: number,
        schoolBoadId?: number, minimumPercentageRequired?: number, fromDate?: Date, toDate?: Date, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classId !== undefined && classId !== null) {
            queryParameters = queryParameters.set('ClassId', <any>classId);
        }
        if (sectionId !== undefined && sectionId !== null) {
            queryParameters = queryParameters.set('SectionId', <any>sectionId);
        }
        if (schoolBoadId !== undefined && schoolBoadId !== null) {
            queryParameters = queryParameters.set('SchoolBoadId', <any>schoolBoadId);
        }
        if (fromDate !== undefined && fromDate !== null) {
            queryParameters = queryParameters.set('FromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined && toDate !== null) {
            queryParameters = queryParameters.set('ToDate', <any>toDate.toISOString());
        }
        if (minimumPercentageRequired !== undefined && minimumPercentageRequired !== null) {
            queryParameters = queryParameters.set('MinimumPercentageRequired', <any>minimumPercentageRequired);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/class-attendace-summary`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }



    getBase64Value(path: any): Promise<any> {
        let toDataURL = null;
        return toDataURL = fetch(path)
            .then(response => response.blob())
            .then(blob => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            }));
    }

    getSchoolDetails(): Promise<any> {
        return this.schoolService.schoolDetailsWithPromise().then(res => {
            if (res.schoolData) {
                res.schoolData.brandingSymbolLogo = res.schoolData.brandingSymbolLogo !== null ? this.storeService.getFilePath(res.schoolData.brandingSymbolLogo.filename)
                    : 'https://dev-school.lshpdev.com/assets/images/logos/academy-front-logo.png';
                res.schoolData.line1 = [res.schoolData.line1, res.schoolData.line2, res.schoolData.line3].filter(c => c).join(',');
                res.schoolData.city = [res.schoolData.city,
                res.schoolData.state, res.schoolData.country, res.schoolData.pincode].filter(a => a).join(',');
                return res.schoolData;
            }
        });
    }

    htmlToStringConversion(id: any): string {
        const html = id;
        let htmlToString;
        if (html.outerHTML) {
            htmlToString = html.outerHTML;
        }
        else if (XMLSerializer) {
            htmlToString = new XMLSerializer().serializeToString(html);
        }
        return htmlToString;
    }

    generatePdf(inputHtml: any, css: string, orientation = 'landscape'): void {
        const outputHtml = {
            id: null,
            name: null
        };
        const htmlToString = this.htmlToStringConversion(inputHtml);

        this.getSchoolDetails().then(schoolDetails => {
            // tslint:disable-next-line:max-line-length
            const header = '<div class="page-header" style="height:94px;"> <div style="padding:10px"> <table class="w100p" style="border: 1px solid rgba(0, 0, 0, .30); width:100%"> <tr> <td style="width:200px;"> <div> <span style="color:#fff">AF</span> <img src= "' + schoolDetails.brandingSymbolLogo + '" width="150" /> </div> </td> <td> <div> <div class="py-4 text-uppercase">' + schoolDetails.name + '</div> <div class="py-4">' + schoolDetails.line1 + '</div> <div class="py-4">' + schoolDetails.city + '</div><div><small>(School Registation Code: ' + schoolDetails.schoolRegCode + ')</small></div> </div> </td> </tr> </table> </div> </div>';

            const targetTableElm = '<html>' + css + '<body>' + header + htmlToString + Messages.FOOTER + '</body></html>';
            outputHtml.id = targetTableElm;
            outputHtml.name = orientation;
            this.reportGenerationService.generatePdf(outputHtml).subscribe(res => {
                if (res.fileName) {
                    window.open(this.storeService.getFilePath(res.fileName));
                }
            });
        });
    }


    /**
    * Report of Student Fee Collections
    * 
    * @param authorization access token
    * @param paymentDateBegin Gets or sets of PaymentDateBegin
    * @param paymentDateEnd Gets or sets of PaymentDateEnd
    * @param classes Gets or sets of Classes
    * @param sections Gets or sets of Sections
    * @param students Gets or sets of Students
    * @param statuses Gets or sets of Statuses
    * @param paymentModes Gets or sets of PaymentModes
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public studentFeeCollections(paymentDateBegin?: string | Date, paymentDateEnd?: string | Date,
        classes?: Array<number>, sections?: Array<number>, students?: Array<string>,
        statuses?: Array<number>, paymentModes?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public studentFeeCollections(paymentDateBegin?: string | Date, paymentDateEnd?: string | Date,
        classes?: Array<number>, sections?: Array<number>, students?: Array<string>,
        statuses?: Array<number>, paymentModes?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public studentFeeCollections(paymentDateBegin?: string | Date, paymentDateEnd?: string | Date,
        classes?: Array<number>, sections?: Array<number>, students?: Array<string>,
        statuses?: Array<number>, paymentModes?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public studentFeeCollections(paymentDateBegin?: string | Date, paymentDateEnd?: string | Date,
        classes?: Array<number>, sections?: Array<number>, students?: Array<string>,
        statuses?: Array<number>, paymentModes?: Array<number>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (paymentDateBegin !== undefined && paymentDateBegin !== null) {
            queryParameters = queryParameters.set('PaymentDateBegin', <any>paymentDateBegin);
        }
        if (paymentDateEnd !== undefined && paymentDateEnd !== null) {
            queryParameters = queryParameters.set('PaymentDateEnd', <any>paymentDateEnd);
        }
        if (classes) {
            classes.forEach((element) => {
                queryParameters = queryParameters.append('Classes', <any>element);
            });
        }
        if (sections) {
            sections.forEach((element) => {
                queryParameters = queryParameters.append('Sections', <any>element);
            });
        }
        if (students) {
            students.forEach((element) => {
                queryParameters = queryParameters.append('Students', <any>element);
            });
        }
        if (statuses) {
            statuses.forEach((element) => {
                queryParameters = queryParameters.append('Statuses', <any>element);
            });
        }
        if (paymentModes) {
            paymentModes.forEach((element) => {
                queryParameters = queryParameters.append('PaymentModes', <any>element);
            });
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-fee-collections`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Examination Schedule Report
    * 
    * @param authorization access token
    * @param classes Gets or Sets Classes
    * @param sections Gets or Sets Sections
    * @param terms Gets or Sets Terms
    * @param classTeacher Gets or Sets ClassTeacher
    * @param testDateBegin Gets or sets of TestDateBegin
    * @param testDateEnd Gets or sets of TestDateEnd
    * @param testName Gets or Sets TestName
    * @param subject Gets or Sets Subject
    * @param subjectTeacher Gets or Sets SubjectTeacher
    * @param testStatus Gets or  Test Status
    * @param sortOrder Gets or Sets SortOrder
    * @param sortBy Gets or Sets SortBy
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public examinationSchedule(classes?: Array<number>, sections?: Array<number>,
        terms?: Array<number>, classTeacher?: string, testDateBegin?: Date,
        testDateEnd?: Date, testName?: string, subject?: string,
        subjectTeacher?: string, testStatus?: Array<string>, sortOrder?: 0 | 1 | -1, sortBy?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public examinationSchedule(classes?: Array<number>, sections?: Array<number>,
        terms?: Array<number>, classTeacher?: string, testDateBegin?: Date,
        testDateEnd?: Date, testName?: string, subject?: string,
        subjectTeacher?: string, testStatus?: Array<string>, sortOrder?: 0 | 1 | -1,
        sortBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public examinationSchedule(classes?: Array<number>, sections?: Array<number>,
        terms?: Array<number>, classTeacher?: string, testDateBegin?: Date,
        testDateEnd?: Date, testName?: string, subject?: string,
        subjectTeacher?: string, testStatus?: Array<string>, sortOrder?: 0 | 1 | -1, sortBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public examinationSchedule(classes?: Array<number>, sections?: Array<number>,
        terms?: Array<number>, classTeacher?: string, testDateBegin?: Date,
        testDateEnd?: Date, testName?: string, subject?: string,
        subjectTeacher?: string, testStatus?: Array<string>, sortOrder?: 0 | 1 | -1, sortBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classes) {
            classes.forEach((element) => {
                queryParameters = queryParameters.append('Classes', <any>element);
            });
        }
        if (sections) {
            sections.forEach((element) => {
                queryParameters = queryParameters.append('Sections', <any>element);
            });
        }
        if (terms) {
            terms.forEach((element) => {
                queryParameters = queryParameters.append('Terms', <any>element);
            });
        }
        if (classTeacher !== undefined && classTeacher !== null) {
            queryParameters = queryParameters.set('ClassTeacher', <any>classTeacher);
        }
        if (testDateBegin !== undefined && testDateBegin !== null) {
            queryParameters = queryParameters.set('TestDateBegin', <any>testDateBegin.toISOString());
        }
        if (testDateEnd !== undefined && testDateEnd !== null) {
            queryParameters = queryParameters.set('TestDateEnd', <any>testDateEnd.toISOString());
        }
        if (testName !== undefined && testName !== null) {
            queryParameters = queryParameters.set('TestName', <any>testName);
        }
        if (subject !== undefined && subject !== null) {
            queryParameters = queryParameters.set('Subject', <any>subject);
        }
        if (subjectTeacher !== undefined && subjectTeacher !== null) {
            queryParameters = queryParameters.set('SubjectTeacher', <any>subjectTeacher);
        }
        if (testStatus) {
            testStatus.forEach((element) => {
                queryParameters = queryParameters.append('TestStatus', <any>element);
            });
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('SortOrder', <any>sortOrder);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('SortBy', <any>sortBy);
        }

        let headers = this.defaultHeaders;
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/Examination-schedule-report`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Report of Student Fee Collections
    * 
    * @param id 
    * @param authorization access token
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public studentFeeReceipts(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public studentFeeReceipts(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public studentFeeReceipts(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public studentFeeReceipts(id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling studentFeeReceipts.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('Id', <any>id);
        }

        let headers = this.defaultHeaders;


        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/student-fee-recipts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * list of students details with their subject grades
     * 
     * @param authorization access token
     * @param classes Gets or sets of Classes
     * @param sections Gets or sets of Sections
     * @param gradingTerms Gets or sets of GradingTerms
     * @param courseCategories Gets or sets of CourseCategories
     * @param courses Gets or sets of Courses
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public marksEntryReport(classes?: Array<string>, sections?: Array<string>,
        gradingTerms?: Array<string>, courseCategories?: Array<string>, courses?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public marksEntryReport(classes?: Array<string>, sections?: Array<string>,
        gradingTerms?: Array<string>, courseCategories?: Array<string>, courses?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public marksEntryReport(classes?: Array<string>, sections?: Array<string>,
        gradingTerms?: Array<string>, courseCategories?: Array<string>, courses?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public marksEntryReport(classes?: Array<string>, sections?: Array<string>,
        gradingTerms?: Array<string>, courseCategories?: Array<string>, courses?: Array<string>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (classes) {
            classes.forEach((element) => {
                queryParameters = queryParameters.append('Classes', <any>element);
            });
        }
        if (sections) {
            sections.forEach((element) => {
                queryParameters = queryParameters.append('Sections', <any>element);
            });
        }
        if (gradingTerms) {
            gradingTerms.forEach((element) => {
                queryParameters = queryParameters.append('GradingTerms', <any>element);
            });
        }
        if (courseCategories) {
            courseCategories.forEach((element) => {
                queryParameters = queryParameters.append('CourseCategories', <any>element);
            });
        }
        if (courses) {
            courses.forEach((element) => {
                queryParameters = queryParameters.append('Courses', <any>element);
            });
        }

        let headers = this.defaultHeaders;
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/SchoolReports/students-marks-entry`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
}
